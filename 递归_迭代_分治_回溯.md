# 从“搬砖”到“指挥官”：彻底搞懂编程四大心法

## 第一部分：形式之争 —— 迭代与递归

这一部分解决的是 **“怎么重复做一件事”** 的问题。

### 1. 迭代 (Iteration)：勤劳的搬砖工

**定义**：利用循环结构（`for`, `while`），一步一步逼近结果。

**比喻**：你想吃掉一碗米饭。迭代就是你拿起勺子，一口一口地吃，直到碗空了（循环结束条件）。

**特点**：

- **自下而上**：从初始状态开始，一步步累加。
- **省空间**：通常只用几个变量记录当前状态。

**代码示例（计算 1 到 n 的和）：**

```Python
def sum_iteration(n):
    total = 0
    # 就像爬楼梯，一步一步往上加
    for i in range(1, n + 1):
        total += i
    return total
```



### 2. 递归 (Recursion)：对下询问，对上负责

**定义**：函数自己调用自己。

**比喻**：你想知道“你前面的第10个人是谁”。

- 你问第9个人：“你前面是谁？”（你不用管他怎么算，你等着就行）。
- 第9个人问第8个人：“你前面是谁？”
- ...
- 直到第1个人（**Base Case**），他说：“我前面没人，我是第一名”。
- 然后结果一层层传回来。

**特点**：

- **自上而下**：先把大问题甩给下一层，直到触底反弹。
- **费空间**：每一层“甩锅”都需要在内存（栈）里记录，如果层数太深会栈溢出（Stack Overflow）。

**代码示例（计算 1 到 n 的和）：**

```Python
def sum_recursion(n):
    # 1. 终止条件 (Base Case)：到底了，不能再甩锅了
    if n == 1:
        return 1
    
    # 2. 递归公式 (Recursive Step)：我 = 我 + 剩下的任务
    return n + sum_recursion(n - 1)
```

> **总结**：**迭代**是自己干，**递归**是找替身干。所有的递归通常都能改写成迭代（用栈模拟），但递归的逻辑往往更符合人类对复杂问题的思考方式。



## 第二部分：策略之争 —— 分治与回溯

这一部分解决的是 **“面对复杂问题该用什么套路”**。它们通常都需要用到“递归”作为实现手段。

### 3. 分治 (Divide and Conquer)：化整为零

**定义**：将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

**口诀**：**分 (Divide) -> 治 (Conquer) -> 合 (Combine)**。

**比喻**：**年级大扫除**。

1. **分**：校长把任务分给班主任，班主任分给组长，组长分给个人。
2. **治**：个人把自己的桌子擦干净（Base Case）。
3. **合**：组长检查全组干净了 -> 班主任检查全班干净了 -> 校长宣布全校干净了。

**典型应用**：归并排序 (Merge Sort)、快速排序 (Quick Sort)。

**代码示例（归并排序的伪逻辑）：**

```Python
def merge_sort(nums):
    # 1. Base Case: 只有一个数，不用排了
    if len(nums) <= 1:
        return nums
    
    # 2. Divide (分): 一刀两断
    mid = len(nums) // 2
    left_part = merge_sort(nums[:mid])  # 递归处理左边
    right_part = merge_sort(nums[mid:]) # 递归处理右边
    
    # 3. Combine (合): 把两个有序的数组合并成一个
    return merge(left_part, right_part)
```

**关键点**：分治法的核心在于**互不干扰**。左边排好序，和右边排好序，这两件事是独立的，最后拼起来就行。



### 4. 回溯 (Backtracking)：不撞南墙不回头

**定义**：一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即**回溯**并且再次尝试。

**口诀**：**选择 -> 递归 -> 撤销**。

**比喻**：**走迷宫**。

1. 走到一个路口，选择左边。
2. 一直走，发现是死胡同。
3. **回溯**（退回）到刚才的路口。
4. **撤销**刚才的选择（把“左边走过了”这个念头忘掉），选择右边。
5. 继续走。

**典型应用**：全排列、八皇后问题、数独。

**代码示例（全排列 - LeetCode 46）：**

```Python
def permute(nums):
    res = []
    path = [] # 记录当前走过的路径
    
    def backtrack(available_nums):
        # 1. 结束条件：所有数都选完了
        if not available_nums:
            res.append(path[:]) # 记录答案
            return

        for i in range(len(available_nums)):
            current_num = available_nums[i]
            
            # --- 做选择 ---
            path.append(current_num)
            
            # --- 递归 (进入下一层决策) ---
            # 剩下的数字里不能包含当前选的这个
            backtrack(available_nums[:i] + available_nums[i+1:])
            
            # --- 撤销选择 (回溯的核心！) ---
            path.pop() # 把刚才选的数拿出来，准备尝试下一个数
            
    backtrack(nums)
    return res
```

**关键点**：回溯的核心在于**“状态重置”**。如果不撤销选择，你的程序就会认为那条死胡同永远堵着，无法去尝试别的路径。

------

## 终极总结表

| **概念** | **类别** | **核心一句话**           | **经典例子**       | **你的角色**        |
| -------- | -------- | ------------------------ | ------------------ | ------------------- |
| **迭代** | 实现手段 | 循环往复，直到成功       | `for` 循环遍历数组 | 搬砖工 (一步步做)   |
| **递归** | 实现手段 | 自己调用自己，层层递进   | 计算阶乘、DFS      | 指挥官 (层层下令)   |
| **分治** | 算法思想 | 大事化小，分而治之       | 归并排序           | 项目经理 (拆分任务) |
| **回溯** | 算法思想 | 一条路走到黑，不通就回头 | 走迷宫、全排列     | 探险家 (试错探索)   |

**它们之间的关系**：

- **递归**是实现**分治**和**回溯**的最常用工具。
- **分治**通常将问题切开后，两边**互不干扰**。
- **回溯**是在一棵决策树上找路径，如果不通必须**回头**（撤销状态）。